# A password generator

Create a file named `pass` and type the following code into it.

{{correct-horse-battery-staple}}

To run this program, you need to make it e**x**ecutable using the command
`chmod +x pass`. Then you can run it by typing `./pass` and pressing
<kbd>Enter</kbd>.

It prints out a password when you run it. It prints out the same password every
time, but we'll fix that soon enough.

The first line (`#!/usr/bin/env bash`) is called a
[shebang](https://en.wikipedia.org/wiki/Shebang_(Unix)) line. (`#` is a hash
character, and `!` is a bang character, so together they form a hash-bang, or
shebang for short.) The shebang line allows you to run scripts the same way you
run binaries, so you can type `./pass` instead of `bash pass`. When the OS
goes to execute a file that begins with `#!`, it runs the program that comes
after the `#!` instead, and passes the file to that program as an argument. So
if the `pass` script began with `#!/bin/bash`, it would be executed using
`/bin/bash pass`.

However, the `bash` program might not be located at `/bin/bash` on all systems.
To make `pass` more portable, the `env` program is used. `env` is a program
that runs the given command, optionally in a modified **env**ironment. It is
used in shebang lines because it runs commands similar to how commands are run
on the shell: it looks in your `$PATH` to locate the command you gave. So with
a shebang line of `#!/usr/bin/env bash`, the `bash` command will be located
properly, wherever it may be on your system.

The reason you can't use something like `#!bash`, and expect it to use `$PATH`
to find `bash` like a shell command would, is that shebang scripts are
[handled by the OS](https://lwn.net/Articles/630727/) at a very
[low level](http://lxr.free-electrons.com/source/fs/binfmt_script.c?v=3.18).

`bash` stands for **B**ourne-**a**gain **sh**ell, which was written to replace
the [Bourne shell](https://en.wikipedia.org/wiki/Bourne_shell) (`sh`). `bash`
is very widely available, and is the default shell on most Unix systems.

So that's line 1.

Moving on to line 3, we have an `echo` command. `echo` is a
program that just prints out the command line arguments it is given. We give it
a quoted argument. The shell
[removes the quotes](https://www.gnu.org/software/bash/manual/html_node/Quote-Removal.html)
before passing the argument to `echo`, and `echo` prints the password to the
standard output.

Let's try assigning the password to a variable, and printing out the variable.

{{variable}}

When the first word of a line contains an `=` character, it is interpreted as
an assignment statement instead of a command. There must not be any whitespace
around the `=`. If you wrote `pass = "correcthorsebatterystaple"`, then Bash
would try to execute a program named `pass` and pass it the arguments `=` and
`correcthorsebatterystaple`.

Once again, the quotes around `"correcthorsebatterystaple"` are not necessary.
The quotes are removed before assigning the value to the variable.

When a `$` precedes a variable name, as in `echo "$pass"`, the variable is
expanded to whatever its value is. It's good practice to put double quotes
around variable expansions, as it ensures that the expanded value is passed as
a single argument. If `$pass` contained the value `a b c`, then `echo $pass`
would expand to `echo a b c`, while `echo "$pass"` would expand to
`echo "a b c"` which is usually what you want.

Now let's actually generate a random password each time the program is run.

{{urandom}}

There's a lot going on in this one-liner. Let's see how to build this one-liner
incrementally, using the shell interactively:

    $ cat /dev/urandom

(The `$` is just a prompt to show that the command is to be typed at the shell,
so for this example you want to type `cat /dev/urandom`.)

[`/dev/random`](https://en.wikipedia.org/wiki//dev/random) is a special device
file that produces an infinite stream of random bytes. If it doesn't have
enough environmental noise to generate cryptographically secure random numbers,
then it will [block](https://en.wikipedia.org/wiki/Blocking_(computing)) until
until it does. `/dev/urandom` is an alternative to `/dev/random` that never
blocks, at the cost of being possibly slightly less random. It is still
intended to be used for cryptographic purposes though, so `pass` uses
`/dev/urandom` as its source of randomness.

You'll get a lot of garbage output from the above command because a lot of the
bytes won't be printable ASCII characters. Press <kbd>Ctrl-C</kbd> to make it
stop.

    $ LC_ALL=C tr -dc "[:graph:]" < /dev/urandom

This command uses [`tr`](https://en.wikipedia.org/wiki/Tr_(Unix)) to remove all
the non-**graph**ical characters from the random stream of bytes. A graphical
character is any ordinary ASCII character that isn't whitespace. `tr` is
typically used to **tr**anslate characters, as in `tr 013 ole <<<'h3110'`. The
`-d` option makes it delete certain characters instead. `[:graph:]` is a
character class meaning "any graphical character", and the `-c` option inverts
that argument, so that the command deletes all **non**-graphical characters.

The command is preceded by the variable assignment `LC_ALL=C`. This sets the
[locale](https://en.wikipedia.org/wiki/C_localization_functions) to the `C`
locale for the duration of the `tr` command. The `C` locale is a simple locale
that treats characters as bytes. The default locale is probably based on UTF-8,
which causes `tr` to fail when reading from `/dev/urandom`, complaining about
an illegal byte sequence.

We use `<` to
[redirect](https://en.wikipedia.org/wiki/Redirection_(computing)) the standard
input of the `tr` command to be the `/dev/urandom` file.

All that's left to do is to limit the output of the command to, say, 25
characters, and save it in the `$pass` variable. Bash has a built-in command,
`read`, that can do both of these things at once:

    $ read -r -n 25 pass < <(LC_ALL=C tr -dc "[:graph:]" < /dev/urandom)
    $ echo $pass
    Qd;p"Jr;:6)G8h5*,L$>^X<z)

`read` is typically used to read input from the user and put it in a variable.
We use a special type of redirection to set the output of our `tr` command as
the standard input for the `read` command. The `-n 25` option causes it to read
25 characters, and the `-r` option signifies "raw" input which disables
backslash-escaping in the input.

The `<(command)` form actually expands to the name of a temporary file,
something like `/dev/fd/63`. Try running `echo <(ls)` to see what `<(ls)` gets
expanded to. The file is a
[named pipe](https://en.wikipedia.org/wiki/Named_pipe), which is a special type
of file that only exists in memory (not on disk). In the `echo <(ls)` example,
what the shell does is it creates a named pipe, sets the `ls` command's
standard output to be that named pipe, and then replaces `<(ls)` with the
filename of the named pipe. This allows us to read the `ls` command's output
however we want. For example, `cat < <(ls)` exands to something like
`cat < /dev/fd/63`, and causes `cat` to use the output of the `ls` command as
its standard input.

Most of the time, you would use anonymous pipes in the shell, as they have a
much cleaner syntax. For example, you would write `ls | cat` instead of
`cat < <(ls)` to pipe the output of `ls` to `cat`. But this does not work when
piping input to `read`. Try `echo asdf | read -r test`, and then `echo $test`.
You'll see that `$test` is empty instead of containing the string `asdf`.
That's because with anonymous pipes, each command is
[run in a separate subshell](http://mywiki.wooledge.org/BashFAQ/024). So `read`
sets the `$test` variable in its own subshell's environment, but that
environment isn't available to you and disappears when `read` finishes
executing. A named pipe fixes this issue by having `read` run in the current
shell's environment: `read -r test < <(echo asdf)`.

{{env-variables}}

all caps, setting env variables, string interpolation, quoting, default values

{{function}}

functions, function calls, local variables

{{command}}

if-else, [[ vs. [, == vs. =, more about quotes, command line arguments

{{version}}

elif, || vs. -o, heredocs, tabs in heredocs, cat

{{case}}

case statements

{{help}}

$0, echo with no arguments, interpolation in heredoc

{{program-name}}

`##` expansion

{{exit-success}}

exit, exit codes, why we're forcing a successful exit status

{{generate-length}}

function arguments

{{pass-length-usage}}

.

{{arguments}}

$@, shift

{{die}}

redirection to stderr, $@, failure exit status

{{validate-length}}

not operator, regex operator, regex, `[[ ... ]] &&` idiom

{{validate-pass}}

string length expansion, arithmetic operators, `[[ ... ]] ||` idiom

