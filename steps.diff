~~~ step: correct-horse-battery-staple
diff --git a/pass b/pass
new file mode 100644
--- /dev/null
+++ b/pass
@@ -0,0 +1,3 @@
+#!/usr/bin/env bash
+
+echo "correcthorsebatterystaple"

~~~ step: urandom
diff --git a/pass b/pass
--- a/pass
+++ b/pass
@@ -1,3 +1,3 @@
 #!/usr/bin/env bash
 
-echo "correcthorsebatterystaple"
+LC_ALL=C tr -dc "[:graph:]" < /dev/urandom

~~~ step: take
diff --git a/pass b/pass
--- a/pass
+++ b/pass
@@ -1,3 +1,4 @@
 #!/usr/bin/env bash
 
-LC_ALL=C tr -dc "[:graph:]" < /dev/urandom
+read -r -n 25 pass < <(LC_ALL=C tr -dc "[:graph:]" < /dev/urandom)
+echo $pass

~~~ step: variables
diff --git a/pass b/pass
--- a/pass
+++ b/pass
@@ -1,4 +1,7 @@
 #!/usr/bin/env bash
 
-read -r -n 25 pass < <(LC_ALL=C tr -dc "[:graph:]" < /dev/urandom)
+GENERATED_LENGTH="${PASSWORD_STORE_GENERATED_LENGTH:-25}"
+CHARACTER_SET="${PASSWORD_STORE_CHARACTER_SET:-[:graph:]}"
+
+read -r -n $GENERATED_LENGTH pass < <(LC_ALL=C tr -dc "$CHARACTER_SET" < /dev/urandom)
 echo $pass

~~~ step: function
diff --git a/pass b/pass
--- a/pass
+++ b/pass
@@ -3,5 +3,9 @@
 GENERATED_LENGTH="${PASSWORD_STORE_GENERATED_LENGTH:-25}"
 CHARACTER_SET="${PASSWORD_STORE_CHARACTER_SET:-[:graph:]}"
 
-read -r -n $GENERATED_LENGTH pass < <(LC_ALL=C tr -dc "$CHARACTER_SET" < /dev/urandom)
-echo $pass
+cmd_generate() {
+  read -r -n $GENERATED_LENGTH pass < <(LC_ALL=C tr -dc "$CHARACTER_SET" < /dev/urandom)
+  echo $pass
+}
+
+cmd_generate

~~~ step: command
diff --git a/pass b/pass
--- a/pass
+++ b/pass
@@ -8,4 +8,8 @@ cmd_generate() {
   echo $pass
 }
 
-cmd_generate
+case "$1" in
+  generate) shift;           cmd_generate "$@" ;;
+  *)                         echo "Unrecognized command '$1'." ;;
+esac
+exit 0

~~~ step: version
diff --git a/pass b/pass
--- a/pass
+++ b/pass
@@ -3,12 +3,28 @@
 GENERATED_LENGTH="${PASSWORD_STORE_GENERATED_LENGTH:-25}"
 CHARACTER_SET="${PASSWORD_STORE_CHARACTER_SET:-[:graph:]}"
 
+cmd_version() {
+  cat <<-_EOF
+	============================================
+	= pass: the standard unix password manager =
+	=                                          =
+	=                   v1.7                   =
+	=                                          =
+	=             Jason A. Donenfeld           =
+	=               Jason@zx2c4.com            =
+	=                                          =
+	=      http://www.passwordstore.org/       =
+	============================================
+	_EOF
+}
+
 cmd_generate() {
   read -r -n $GENERATED_LENGTH pass < <(LC_ALL=C tr -dc "$CHARACTER_SET" < /dev/urandom)
   echo $pass
 }
 
 case "$1" in
+  version|--version) shift;  cmd_version "$@" ;;
   generate) shift;           cmd_generate "$@" ;;
   *)                         echo "Unrecognized command '$1'." ;;
 esac

~~~ step: help
diff --git a/pass b/pass
--- a/pass
+++ b/pass
@@ -18,12 +18,31 @@ cmd_version() {
 	_EOF
 }
 
+cmd_usage() {
+  cmd_version
+  echo
+  cat <<-_EOF
+	Usage:
+	    $PROGRAM generate
+	        Generate a new password.
+	    $PROGRAM help
+	        Show this text.
+	    $PROGRAM version
+	        Show version information.
+
+	More information may be found in the pass(1) man page.
+	_EOF
+}
+
 cmd_generate() {
   read -r -n $GENERATED_LENGTH pass < <(LC_ALL=C tr -dc "$CHARACTER_SET" < /dev/urandom)
   echo $pass
 }
 
+PROGRAM="${0##*/}"
+
 case "$1" in
+  help|--help) shift;        cmd_usage "$@" ;;
   version|--version) shift;  cmd_version "$@" ;;
   generate) shift;           cmd_generate "$@" ;;
   *)                         echo "Unrecognized command '$1'." ;;

~~~ step: persist
diff --git a/pass b/pass
--- a/pass
+++ b/pass
@@ -1,8 +1,20 @@
 #!/usr/bin/env bash
 
+PREFIX="${PASSWORD_STORE_DIR:-$HOME/.password-store2}"
 GENERATED_LENGTH="${PASSWORD_STORE_GENERATED_LENGTH:-25}"
 CHARACTER_SET="${PASSWORD_STORE_CHARACTER_SET:-[:graph:]}"
 
+yesno() {
+  [[ -t 0 ]] || return 0
+  local response
+  read -r -p "$1 [y/N] " response
+  [[ $response == [yY] ]] || exit 1
+}
+die() {
+  echo "$@" >&2
+  exit 1
+}
+
 cmd_version() {
   cat <<-_EOF
 	============================================
@@ -35,8 +47,18 @@ cmd_usage() {
 }
 
 cmd_generate() {
+  [[ $# -ne 1 ]] && die "Usage: $PROGRAM $COMMAND pass-name"
+  local path="$1"
+  mkdir -p -v "$PREFIX/$(dirname "$path")"
+  local passfile="$PREFIX/$path.txt"
+
+  [[ -e $passfile ]] && yesno "An entry already exists for $path. Overwrite it?"
+
   read -r -n $GENERATED_LENGTH pass < <(LC_ALL=C tr -dc "$CHARACTER_SET" < /dev/urandom)
-  echo $pass
+  echo $pass > $passfile
+
+  printf "\e[1m\e[37mThe generated password for \e[4m%s\e[24m is:\e[0m\n\e[1m\e[93m%s\e[0m\n" \
+         "$path" "$pass"
 }
 
 PROGRAM="${0##*/}"

~~~ step: pass-length
diff --git a/pass b/pass
--- a/pass
+++ b/pass
@@ -35,8 +35,8 @@ cmd_usage() {
   echo
   cat <<-_EOF
 	Usage:
-	    $PROGRAM generate
-	        Generate a new password.
+	    $PROGRAM generate pass-name [pass-length]
+	        Generate a new password of pass-length (or $GENERATED_LENGTH if unspecified).
 	    $PROGRAM help
 	        Show this text.
 	    $PROGRAM version
@@ -47,14 +47,15 @@ cmd_usage() {
 }
 
 cmd_generate() {
-  [[ $# -ne 1 ]] && die "Usage: $PROGRAM $COMMAND pass-name"
+  [[ $# -ne 2 && $# -ne 1 ]] && die "Usage: $PROGRAM $COMMAND pass-name [pass-length]"
   local path="$1"
+  local length="${2:-$GENERATED_LENGTH}"
   mkdir -p -v "$PREFIX/$(dirname "$path")"
   local passfile="$PREFIX/$path.txt"
 
   [[ -e $passfile ]] && yesno "An entry already exists for $path. Overwrite it?"
 
-  read -r -n $GENERATED_LENGTH pass < <(LC_ALL=C tr -dc "$CHARACTER_SET" < /dev/urandom)
+  read -r -n $length pass < <(LC_ALL=C tr -dc "$CHARACTER_SET" < /dev/urandom)
   echo $pass > $passfile
 
   printf "\e[1m\e[37mThe generated password for \e[4m%s\e[24m is:\e[0m\n\e[1m\e[93m%s\e[0m\n" \

~~~ step: validation
diff --git a/pass b/pass
--- a/pass
+++ b/pass
@@ -14,6 +14,13 @@ die() {
   echo "$@" >&2
   exit 1
 }
+check_sneaky_paths() {
+  local path
+  for path in "$@"; do
+    [[ $path =~ /\.\.$ || $path =~ ^\.\./ || $path =~ /\.\./ || $path =~ ^\.\.$ ]] && \
+      die "Error: You've attempted to pass a sneaky path to pass. Go home."
+  done
+}
 
 cmd_version() {
   cat <<-_EOF
@@ -50,12 +57,15 @@ cmd_generate() {
   [[ $# -ne 2 && $# -ne 1 ]] && die "Usage: $PROGRAM $COMMAND pass-name [pass-length]"
   local path="$1"
   local length="${2:-$GENERATED_LENGTH}"
+  check_sneaky_paths "$path"
+  [[ ! $length =~ ^[0-9]+$ ]] && die "Error: pass-length \"$length\" must be a number."
   mkdir -p -v "$PREFIX/$(dirname "$path")"
   local passfile="$PREFIX/$path.txt"
 
   [[ -e $passfile ]] && yesno "An entry already exists for $path. Overwrite it?"
 
   read -r -n $length pass < <(LC_ALL=C tr -dc "$CHARACTER_SET" < /dev/urandom)
+  [[ ${#pass} -eq $length ]] || die "Could not generate password from /dev/urandom."
   echo $pass > $passfile
 
   printf "\e[1m\e[37mThe generated password for \e[4m%s\e[24m is:\e[0m\n\e[1m\e[93m%s\e[0m\n" \

~~~ step: show
diff --git a/pass b/pass
--- a/pass
+++ b/pass
@@ -42,6 +42,8 @@ cmd_usage() {
   echo
   cat <<-_EOF
 	Usage:
+	    $PROGRAM show pass-name
+	        Show existing password.
 	    $PROGRAM generate pass-name [pass-length]
 	        Generate a new password of pass-length (or $GENERATED_LENGTH if unspecified).
 	    $PROGRAM help
@@ -53,6 +55,21 @@ cmd_usage() {
 	_EOF
 }
 
+cmd_show() {
+  [[ $# -ne 1 ]] && die "Usage: $PROGRAM $COMMAND pass-name"
+
+  local path="$1"
+  local passfile="$PREFIX/$path.txt"
+  check_sneaky_paths "$path"
+  if [[ -f $passfile ]]; then
+    cat "$passfile"
+  elif [[ -d $PREFIX/$path ]]; then
+    die "Error: $path is a directory."
+  else
+    die "Error: $path is not in the password store."
+  fi
+}
+
 cmd_generate() {
   [[ $# -ne 2 && $# -ne 1 ]] && die "Usage: $PROGRAM $COMMAND pass-name [pass-length]"
   local path="$1"
@@ -73,10 +90,12 @@ cmd_generate() {
 }
 
 PROGRAM="${0##*/}"
+COMMAND="$1"
 
 case "$1" in
   help|--help) shift;        cmd_usage "$@" ;;
   version|--version) shift;  cmd_version "$@" ;;
+  show) shift;               cmd_show "$@" ;;
   generate) shift;           cmd_generate "$@" ;;
   *)                         echo "Unrecognized command '$1'." ;;
 esac

~~~ step: default
diff --git a/pass b/pass
--- a/pass
+++ b/pass
@@ -42,7 +42,7 @@ cmd_usage() {
   echo
   cat <<-_EOF
 	Usage:
-	    $PROGRAM show pass-name
+	    $PROGRAM [show] pass-name
 	        Show existing password.
 	    $PROGRAM generate pass-name [pass-length]
 	        Generate a new password of pass-length (or $GENERATED_LENGTH if unspecified).
@@ -97,6 +97,6 @@ case "$1" in
   version|--version) shift;  cmd_version "$@" ;;
   show) shift;               cmd_show "$@" ;;
   generate) shift;           cmd_generate "$@" ;;
-  *)                         echo "Unrecognized command '$1'." ;;
+  *)                         COMMAND="show"; cmd_show "$@" ;;
 esac
 exit 0

~~~ step: insert
diff --git a/pass b/pass
--- a/pass
+++ b/pass
@@ -44,6 +44,8 @@ cmd_usage() {
 	Usage:
 	    $PROGRAM [show] pass-name
 	        Show existing password.
+	    $PROGRAM insert pass-name
+	        Insert new password.
 	    $PROGRAM generate pass-name [pass-length]
 	        Generate a new password of pass-length (or $GENERATED_LENGTH if unspecified).
 	    $PROGRAM help
@@ -70,6 +72,31 @@ cmd_show() {
   fi
 }
 
+cmd_insert() {
+  [[ $# -ne 1 ]] && die "Usage: $PROGRAM $COMMAND pass-name"
+  local path="${1%/}"
+  local passfile="$PREFIX/$path.txt"
+  check_sneaky_paths "$path"
+
+  [[ -e $passfile ]] && yesno "An entry already exists for $path. Overwite it?"
+
+  mkdir -p -v "$PREFIX/$(dirname "$path")"
+
+  local password password_again
+  while true; do
+    read -r -p "Enter password for $path: " -s password || exit 1
+    echo
+    read -r -p "Retype password for $path: " -s password_again || exit 1
+    echo
+    if [[ $password == "$password_again" ]]; then
+      echo "$password" > "$passfile"
+      break
+    else
+      die "Error: the entered passwords do not match."
+    fi
+  done
+}
+
 cmd_generate() {
   [[ $# -ne 2 && $# -ne 1 ]] && die "Usage: $PROGRAM $COMMAND pass-name [pass-length]"
   local path="$1"
@@ -96,6 +123,7 @@ case "$1" in
   help|--help) shift;        cmd_usage "$@" ;;
   version|--version) shift;  cmd_version "$@" ;;
   show) shift;               cmd_show "$@" ;;
+  insert|add) shift;         cmd_insert "$@" ;;
   generate) shift;           cmd_generate "$@" ;;
   *)                         COMMAND="show"; cmd_show "$@" ;;
 esac

~~~ step: rm
diff --git a/pass b/pass
--- a/pass
+++ b/pass
@@ -48,6 +48,8 @@ cmd_usage() {
 	        Insert new password.
 	    $PROGRAM generate pass-name [pass-length]
 	        Generate a new password of pass-length (or $GENERATED_LENGTH if unspecified).
+	    $PROGRAM rm pass-name
+	        Remove existing password or directory.
 	    $PROGRAM help
 	        Show this text.
 	    $PROGRAM version
@@ -116,6 +118,22 @@ cmd_generate() {
          "$path" "$pass"
 }
 
+cmd_delete() {
+  [[ $# -ne 1 ]] && die "Usage: $PROGRAM $COMMAND pass-name"
+  local path="$1"
+  check_sneaky_paths "$path"
+
+  local passdir="$PREFIX/${path%/}"
+  local passfile="$PREFIX/$path.txt"
+  [[ -f $passfile && -d $passdir && $path == */ || ! -f $passfile ]] && passfile="${passdir%/}/"
+  [[ -e $passfile ]] || die "Error: $path is not in the password store."
+
+  yesno "Are you sure you would like to delete $path?"
+
+  rm -r -f -v "$passfile"
+  rmdir -p "${passfile%/*}" 2>/dev/null
+}
+
 PROGRAM="${0##*/}"
 COMMAND="$1"
 
@@ -125,6 +143,7 @@ case "$1" in
   show) shift;               cmd_show "$@" ;;
   insert|add) shift;         cmd_insert "$@" ;;
   generate) shift;           cmd_generate "$@" ;;
+  delete|rm|remove) shift;   cmd_delete "$@" ;;
   *)                         COMMAND="show"; cmd_show "$@" ;;
 esac
 exit 0

~~~ step: mv
diff --git a/pass b/pass
--- a/pass
+++ b/pass
@@ -50,6 +50,8 @@ cmd_usage() {
 	        Generate a new password of pass-length (or $GENERATED_LENGTH if unspecified).
 	    $PROGRAM rm pass-name
 	        Remove existing password or directory.
+	    $PROGRAM mv old-path new-path
+	        Renames or moves old-path to new-path.
 	    $PROGRAM help
 	        Show this text.
 	    $PROGRAM version
@@ -134,6 +136,30 @@ cmd_delete() {
   rmdir -p "${passfile%/*}" 2>/dev/null
 }
 
+cmd_move() {
+  [[ $# -ne 2 ]] && die "Usage: $PROGRAM $COMMAND old-path new-path"
+  check_sneaky_paths "$@"
+  local old_path="$PREFIX/${1%/}"
+  local old_dir="$old_path"
+  local new_path="$PREFIX/$2"
+
+  if ! [[ -f $old_path.txt && -d $old_path && $1 == */ || ! -f $old_path.txt ]]; then
+    old_dir="${old_path%/*}"
+    old_path="${old_path}.txt"
+  fi
+  echo "$old_path"
+  [[ -e $old_path ]] || die "Error: $1 is not in the password store."
+
+  mkdir -p -v "${new_path%/*}"
+  [[ -d $old_path || -d $new_path || $new_path == */ ]] || new_path="${new_path}.txt"
+
+  local interactive="-i"
+  [[ ! -t 0 ]] && interactive="-f"
+
+  mv $interactive -v "$old_path" "$new_path" || exit 1
+  rmdir -p "$old_dir" 2>/dev/null
+}
+
 PROGRAM="${0##*/}"
 COMMAND="$1"
 
@@ -144,6 +170,7 @@ case "$1" in
   insert|add) shift;         cmd_insert "$@" ;;
   generate) shift;           cmd_generate "$@" ;;
   delete|rm|remove) shift;   cmd_delete "$@" ;;
+  rename|mv) shift;          cmd_move "$@" ;;
   *)                         COMMAND="show"; cmd_show "$@" ;;
 esac
 exit 0

~~~ step: cp
diff --git a/pass b/pass
--- a/pass
+++ b/pass
@@ -52,6 +52,8 @@ cmd_usage() {
 	        Remove existing password or directory.
 	    $PROGRAM mv old-path new-path
 	        Renames or moves old-path to new-path.
+	    $PROGRAM cp old-path new-path
+	        Copies old-path to new-path.
 	    $PROGRAM help
 	        Show this text.
 	    $PROGRAM version
@@ -136,7 +138,10 @@ cmd_delete() {
   rmdir -p "${passfile%/*}" 2>/dev/null
 }
 
-cmd_move() {
+cmd_copy_move() {
+  local move=1
+  [[ $1 == "copy" ]] && move=0
+  shift
   [[ $# -ne 2 ]] && die "Usage: $PROGRAM $COMMAND old-path new-path"
   check_sneaky_paths "$@"
   local old_path="$PREFIX/${1%/}"
@@ -156,8 +161,12 @@ cmd_move() {
   local interactive="-i"
   [[ ! -t 0 ]] && interactive="-f"
 
-  mv $interactive -v "$old_path" "$new_path" || exit 1
-  rmdir -p "$old_dir" 2>/dev/null
+  if [[ $move -eq 1 ]]; then
+    mv $interactive -v "$old_path" "$new_path" || exit 1
+    rmdir -p "$old_dir" 2>/dev/null
+  else
+    cp $interactive -r -v "$old_path" "$new_path" || exit 1
+  fi
 }
 
 PROGRAM="${0##*/}"
@@ -170,7 +179,8 @@ case "$1" in
   insert|add) shift;         cmd_insert "$@" ;;
   generate) shift;           cmd_generate "$@" ;;
   delete|rm|remove) shift;   cmd_delete "$@" ;;
-  rename|mv) shift;          cmd_move "$@" ;;
+  rename|mv) shift;          cmd_copy_move "move" "$@" ;;
+  copy|cp) shift;            cmd_copy_move "copy" "$@" ;;
   *)                         COMMAND="show"; cmd_show "$@" ;;
 esac
 exit 0

~~~ step: init
diff --git a/pass b/pass
--- a/pass
+++ b/pass
@@ -42,6 +42,8 @@ cmd_usage() {
   echo
   cat <<-_EOF
 	Usage:
+	    $PROGRAM init gpg-id...
+	        Initialize new password storage and use gpg-id for encryption.
 	    $PROGRAM [show] pass-name
 	        Show existing password.
 	    $PROGRAM insert pass-name
@@ -63,6 +65,17 @@ cmd_usage() {
 	_EOF
 }
 
+cmd_init() {
+  [[ $# -lt 1 ]] && die "Usage: $PROGRAM $COMMAND gpg-id..."
+
+  local gpg_id="$PREFIX/.gpg-id"
+
+  mkdir -v -p "$PREFIX"
+  printf "%s\n" "$@" > "$gpg_id"
+  local id_print="$(printf "%s, " "$@")"
+  echo "Password store initialized for ${id_print%, }"
+}
+
 cmd_show() {
   [[ $# -ne 1 ]] && die "Usage: $PROGRAM $COMMAND pass-name"
 
@@ -173,6 +186,7 @@ PROGRAM="${0##*/}"
 COMMAND="$1"
 
 case "$1" in
+  init) shift;               cmd_init "$@" ;;
   help|--help) shift;        cmd_usage "$@" ;;
   version|--version) shift;  cmd_version "$@" ;;
   show) shift;               cmd_show "$@" ;;

~~~ step: gpg
diff --git a/pass b/pass
--- a/pass
+++ b/pass
@@ -1,5 +1,11 @@
 #!/usr/bin/env bash
 
+GPG_OPTS=( $PASSWORD_STORE_GPG_OPTS "--quiet" "--yes" "--compress-algo=none" "--no-encrypt-to" )
+GPG="gpg"
+export GPG_TTY="${GPG_TTY:-$(tty 2>/dev/null)}"
+which gpg2 &>/dev/null && GPG="gpg2"
+[[ -n $GPG_AGENT_INFO || $GPG == "gpg2" ]] && GPG_OPTS+=( "--batch" "--use-agent" )
+
 PREFIX="${PASSWORD_STORE_DIR:-$HOME/.password-store2}"
 GENERATED_LENGTH="${PASSWORD_STORE_GENERATED_LENGTH:-25}"
 CHARACTER_SET="${PASSWORD_STORE_CHARACTER_SET:-[:graph:]}"

~~~ step: gpg-winpath
diff --git a/platform/cygwin.sh b/platform/cygwin.sh
new file mode 100644
--- /dev/null
+++ b/platform/cygwin.sh
@@ -0,0 +1,18 @@
+gpg_winpath() {
+  local args=("$@")
+  local could_be_filenames="true"
+  local i
+  for ((i=${#args[@]}-1; i>=0; i--)); do
+    if ( [ $i -gt 0 ] && [ "${args[$i-1]}" = "-o" ] && [ "${args[$i]}" != "-" ] ); then
+      args[$i]="$(cygpath -am "${args[$i]}")"
+    else
+      could_be_filenames="false"
+    fi
+  done
+  $GPG_ORIG "${args[@]}"
+}
+
+if $GPG --help | grep -q 'Home: [A-Z]:[/\\]'; then
+  GPG_ORIG="$GPG"
+  GPG=gpg_winpath
+fi

~~~ step: source-platform
diff --git a/pass b/pass
--- a/pass
+++ b/pass
@@ -28,6 +28,9 @@ check_sneaky_paths() {
   done
 }
 
+source "$(dirname "$0")/platform/$(uname | cut -d _ -f 1 | tr '[:upper:]' '[:lower:]').sh" \
+  2>/dev/null
+
 cmd_version() {
   cat <<-_EOF
 	============================================

~~~ step: gpg-recipients
diff --git a/pass b/pass
--- a/pass
+++ b/pass
@@ -20,6 +20,35 @@ die() {
   echo "$@" >&2
   exit 1
 }
+set_gpg_recipients() {
+  GPG_RECIPIENT_ARGS=( )
+  GPG_RECIPIENTS=( )
+
+  if [[ -n $PASSWORD_STORE_KEY ]]; then
+    for gpg_id in $PASSWORD_STORE_KEY; do
+      GPG_RECIPIENT_ARGS+=( "-r" "$gpg_id" )
+      GPG_RECIPIENTS+=( "$gpg_id" )
+    done
+    return
+  fi
+
+  if [[ ! -f "$PREFIX/.gpg-id" ]]; then
+    cat >&2 <<-_EOF
+	Error: You must run:
+	    $PROGRAM init your-gpg-id
+	before you may use the password store.
+
+	_EOF
+    cmd_usage
+    exit 1
+  fi
+
+  local gpg_id
+  while read -r gpg_id; do
+    GPG_RECIPIENT_ARGS+=( "-r" "$gpg_id" )
+    GPG_RECIPIENTS+=( "$gpg_id" )
+  done < "$PREFIX/.gpg-id"
+}
 check_sneaky_paths() {
   local path
   for path in "$@"; do

~~~ step: txt-to-gpg
diff --git a/pass b/pass
--- a/pass
+++ b/pass
@@ -118,7 +118,7 @@ cmd_show() {
   [[ $# -ne 1 ]] && die "Usage: $PROGRAM $COMMAND pass-name"
 
   local path="$1"
-  local passfile="$PREFIX/$path.txt"
+  local passfile="$PREFIX/$path.gpg"
   check_sneaky_paths "$path"
   if [[ -f $passfile ]]; then
     cat "$passfile"
@@ -132,7 +132,7 @@ cmd_show() {
 cmd_insert() {
   [[ $# -ne 1 ]] && die "Usage: $PROGRAM $COMMAND pass-name"
   local path="${1%/}"
-  local passfile="$PREFIX/$path.txt"
+  local passfile="$PREFIX/$path.gpg"
   check_sneaky_paths "$path"
 
   [[ -e $passfile ]] && yesno "An entry already exists for $path. Overwite it?"
@@ -161,7 +161,7 @@ cmd_generate() {
   check_sneaky_paths "$path"
   [[ ! $length =~ ^[0-9]+$ ]] && die "Error: pass-length \"$length\" must be a number."
   mkdir -p -v "$PREFIX/$(dirname "$path")"
-  local passfile="$PREFIX/$path.txt"
+  local passfile="$PREFIX/$path.gpg"
 
   [[ -e $passfile ]] && yesno "An entry already exists for $path. Overwrite it?"
 
@@ -179,7 +179,7 @@ cmd_delete() {
   check_sneaky_paths "$path"
 
   local passdir="$PREFIX/${path%/}"
-  local passfile="$PREFIX/$path.txt"
+  local passfile="$PREFIX/$path.gpg"
   [[ -f $passfile && -d $passdir && $path == */ || ! -f $passfile ]] && passfile="${passdir%/}/"
   [[ -e $passfile ]] || die "Error: $path is not in the password store."
 
@@ -199,15 +199,15 @@ cmd_copy_move() {
   local old_dir="$old_path"
   local new_path="$PREFIX/$2"
 
-  if ! [[ -f $old_path.txt && -d $old_path && $1 == */ || ! -f $old_path.txt ]]; then
+  if ! [[ -f $old_path.gpg && -d $old_path && $1 == */ || ! -f $old_path.gpg ]]; then
     old_dir="${old_path%/*}"
-    old_path="${old_path}.txt"
+    old_path="${old_path}.gpg"
   fi
   echo "$old_path"
   [[ -e $old_path ]] || die "Error: $1 is not in the password store."
 
   mkdir -p -v "${new_path%/*}"
-  [[ -d $old_path || -d $new_path || $new_path == */ ]] || new_path="${new_path}.txt"
+  [[ -d $old_path || -d $new_path || $new_path == */ ]] || new_path="${new_path}.gpg"
 
   local interactive="-i"
   [[ ! -t 0 ]] && interactive="-f"

~~~ step: encrypt
diff --git a/pass b/pass
--- a/pass
+++ b/pass
@@ -138,6 +138,7 @@ cmd_insert() {
   [[ -e $passfile ]] && yesno "An entry already exists for $path. Overwite it?"
 
   mkdir -p -v "$PREFIX/$(dirname "$path")"
+  set_gpg_recipients
 
   local password password_again
   while true; do
@@ -146,7 +147,8 @@ cmd_insert() {
     read -r -p "Retype password for $path: " -s password_again || exit 1
     echo
     if [[ $password == "$password_again" ]]; then
-      echo "$password" > "$passfile"
+      $GPG -e "${GPG_RECIPIENT_ARGS[@]}" -o "$passfile" "${GPG_OPTS[@]}" <<< "$password" \
+	|| die "Password encryption aborted."
       break
     else
       die "Error: the entered passwords do not match."
@@ -161,13 +163,15 @@ cmd_generate() {
   check_sneaky_paths "$path"
   [[ ! $length =~ ^[0-9]+$ ]] && die "Error: pass-length \"$length\" must be a number."
   mkdir -p -v "$PREFIX/$(dirname "$path")"
+  set_gpg_recipients
   local passfile="$PREFIX/$path.gpg"
 
   [[ -e $passfile ]] && yesno "An entry already exists for $path. Overwrite it?"
 
   read -r -n $length pass < <(LC_ALL=C tr -dc "$CHARACTER_SET" < /dev/urandom)
   [[ ${#pass} -eq $length ]] || die "Could not generate password from /dev/urandom."
-  echo $pass > $passfile
+  $GPG -e "${GPG_RECIPIENT_ARGS[@]}" -o "$passfile" "${GPG_OPTS[@]}" <<<"$pass" \
+    || die "Password encryption aborted."
 
   printf "\e[1m\e[37mThe generated password for \e[4m%s\e[24m is:\e[0m\n\e[1m\e[93m%s\e[0m\n" \
          "$path" "$pass"

~~~ step: decrypt
diff --git a/pass b/pass
--- a/pass
+++ b/pass
@@ -121,7 +121,7 @@ cmd_show() {
   local passfile="$PREFIX/$path.gpg"
   check_sneaky_paths "$path"
   if [[ -f $passfile ]]; then
-    cat "$passfile"
+    $GPG -d "${GPG_OPTS[@]}" "$passfile" || exit $?
   elif [[ -d $PREFIX/$path ]]; then
     die "Error: $path is a directory."
   else

~~~ step: reencrypt-path
diff --git a/pass b/pass
--- a/pass
+++ b/pass
@@ -49,6 +49,43 @@ set_gpg_recipients() {
     GPG_RECIPIENTS+=( "$gpg_id" )
   done < "$PREFIX/.gpg-id"
 }
+reencrypt_path() {
+  local prev_gpg_recipients="" gpg_keys="" current_keys="" index passfile
+  local groups="$($GPG $PASSWORD_STORE_GPG_OPTS --list-config --with-colons | grep "^cfg:group:.*")"
+  while read -r -d "" passfile; do
+    local passfile_dir="${passfile%/*}"
+    passfile_dir="${passfile_dir#$PREFIX}"
+    passfile_dir="${passfile_dir#/}"
+    local passfile_display="${passfile#$PREFIX/}"
+    passfile_display="${passfile_display%.gpg}"
+    local passfile_temp="${passfile}.tmp.${RANDOM}.${RANDOM}.${RANDOM}.${RANDOM}.--"
+
+    set_gpg_recipients "$passfile_dir"
+    if [[ $prev_gpg_recipients != "${GPG_RECIPIENTS[*]}" ]]; then
+      for index in "${!GPG_RECIPIENTS[@]}"; do
+        local group="$(sed -n "s/^cfg:group:$(sed 's/[\/&]/\\&/g' \
+	  <<<"${GPG_RECIPIENTS[$index]}"):\\(.*\\)\$/\\1/p" <<<"$groups" | head -n 1)"
+        [[ -z $group ]] && continue
+        IFS=";" eval 'GPG_RECIPIENTS+=( $group )' # http://unix.stackexchange.com/a/92190
+        unset GPG_RECIPIENTS[$index]
+      done
+      gpg_keys="$($GPG $PASSWORD_STORE_GPG_OPTS --list-keys --with-colons "${GPG_RECIPIENTS[@]}" \
+	| sed -n 's/sub:[^:]*:[^:]*:[^:]*:\([^:]*\):[^:]*:[^:]*:[^:]*:[^:]*:[^:]*:[^:]*:[a-zA-Z]*e[a-zA-Z]*:.*/\1/p' \
+        | LC_ALL=C sort -u)"
+    fi
+    current_keys="$($GPG $PASSWORD_STORE_GPG_OPTS -v --no-secmem-warning --no-permission-warning \
+                    --decrypt --list-only --keyid-format long "$passfile" 2>&1 \
+                    | cut -d ' ' -f 5 | LC_ALL=C sort -u)"
+
+    if [[ $gpg_keys != "$current_keys" ]]; then
+      echo "$passfile_display: reencrypting to ${gpg_keys//$'\n'/ }"
+      $GPG -d "${GPG_OPTS[@]}" "$passfile" \
+	| $GPG -e "${GPG_RECIPIENT_ARGS[@]}" -o "$passfile_temp" "${GPG_OPTS[@]}" \
+	&& mv "$passfile_temp" "$passfile" || rm -f "$passfile_temp"
+    fi
+    prev_gpg_recipients="${GPG_RECIPIENTS[*]}"
+  done < <(find "$1" -path '*/.git' -prune -o -iname '*.gpg' -print0)
+}
 check_sneaky_paths() {
   local path
   for path in "$@"; do

~~~ step: init-reencrypt
diff --git a/pass b/pass
--- a/pass
+++ b/pass
@@ -119,6 +119,7 @@ cmd_usage() {
 	Usage:
 	    $PROGRAM init gpg-id...
 	        Initialize new password storage and use gpg-id for encryption.
+		Reencrypt existing passwords using new gpg-id.
 	    $PROGRAM [show] pass-name
 	        Show existing password.
 	    $PROGRAM insert pass-name
@@ -149,6 +150,8 @@ cmd_init() {
   printf "%s\n" "$@" > "$gpg_id"
   local id_print="$(printf "%s, " "$@")"
   echo "Password store initialized for ${id_print%, }"
+
+  reencrypt_path "$PREFIX/"
 }
 
 cmd_show() {

~~~ step: generic-clip
diff --git a/pass b/pass
--- a/pass
+++ b/pass
@@ -7,6 +7,7 @@ which gpg2 &>/dev/null && GPG="gpg2"
 [[ -n $GPG_AGENT_INFO || $GPG == "gpg2" ]] && GPG_OPTS+=( "--batch" "--use-agent" )
 
 PREFIX="${PASSWORD_STORE_DIR:-$HOME/.password-store2}"
+X_SELECTION="${PASSWORD_STORE_X_SELECTION:-clipboard}"
 GENERATED_LENGTH="${PASSWORD_STORE_GENERATED_LENGTH:-25}"
 CHARACTER_SET="${PASSWORD_STORE_CHARACTER_SET:-[:graph:]}"
 
@@ -94,6 +95,12 @@ check_sneaky_paths() {
   done
 }
 
+clip() {
+  echo -n "$1" | xclip -selection "$X_SELECTION" \
+    || die "Error: Could not copy data to the clipboard"
+  echo "Copied $2 to clipboard."
+}
+
 source "$(dirname "$0")/platform/$(uname | cut -d _ -f 1 | tr '[:upper:]' '[:lower:]').sh" \
   2>/dev/null
 

~~~ step: cygwin-clip
diff --git a/platform/cygwin.sh b/platform/cygwin.sh
--- a/platform/cygwin.sh
+++ b/platform/cygwin.sh
@@ -1,3 +1,8 @@
+clip() {
+  echo -n "$1" > /dev/clipboard
+  echo "Copied $2 to clipboard."
+}
+
 gpg_winpath() {
   local args=("$@")
   local could_be_filenames="true"

~~~ step: macos-clip
diff --git a/platform/darwin.sh b/platform/darwin.sh
new file mode 100644
--- /dev/null
+++ b/platform/darwin.sh
@@ -0,0 +1,4 @@
+clip() {
+  echo -n "$1" | pbcopy
+  echo "Copied $2 to clipboard."
+}

~~~ step: show-generate-clip
diff --git a/pass b/pass
--- a/pass
+++ b/pass
@@ -127,11 +127,11 @@ cmd_usage() {
 	    $PROGRAM init gpg-id...
 	        Initialize new password storage and use gpg-id for encryption.
 		Reencrypt existing passwords using new gpg-id.
-	    $PROGRAM [show] pass-name
+	    $PROGRAM [show] [-c] pass-name
 	        Show existing password.
 	    $PROGRAM insert pass-name
 	        Insert new password.
-	    $PROGRAM generate pass-name [pass-length]
+	    $PROGRAM generate [-c] pass-name [pass-length]
 	        Generate a new password of pass-length (or $GENERATED_LENGTH if unspecified).
 	    $PROGRAM rm pass-name
 	        Remove existing password or directory.
@@ -162,13 +162,23 @@ cmd_init() {
 }
 
 cmd_show() {
+  local clip=0
+  if [[ $1 == "-c" ]]; then
+    clip=1
+    shift
+  fi
   [[ $# -ne 1 ]] && die "Usage: $PROGRAM $COMMAND pass-name"
 
   local path="$1"
   local passfile="$PREFIX/$path.gpg"
   check_sneaky_paths "$path"
   if [[ -f $passfile ]]; then
-    $GPG -d "${GPG_OPTS[@]}" "$passfile" || exit $?
+    if [[ $clip -eq 0 ]]; then
+      $GPG -d "${GPG_OPTS[@]}" "$passfile" || exit $?
+    else
+      local pass="$($GPG -d "${GPG_OPTS[@]}" "$passfile")"
+      clip "$pass" "$path"
+    fi
   elif [[ -d $PREFIX/$path ]]; then
     die "Error: $path is a directory."
   else
@@ -204,6 +214,12 @@ cmd_insert() {
 }
 
 cmd_generate() {
+  local clip=0 pass
+  if [[ $1 == "-c" ]]; then
+    clip=1
+    shift
+  fi
+
   [[ $# -ne 2 && $# -ne 1 ]] && die "Usage: $PROGRAM $COMMAND pass-name [pass-length]"
   local path="$1"
   local length="${2:-$GENERATED_LENGTH}"
@@ -220,8 +236,12 @@ cmd_generate() {
   $GPG -e "${GPG_RECIPIENT_ARGS[@]}" -o "$passfile" "${GPG_OPTS[@]}" <<<"$pass" \
     || die "Password encryption aborted."
 
-  printf "\e[1m\e[37mThe generated password for \e[4m%s\e[24m is:\e[0m\n\e[1m\e[93m%s\e[0m\n" \
-         "$path" "$pass"
+  if [[ $clip -eq 1 ]]; then
+    clip "$pass" "$path"
+  else
+    printf "\e[1m\e[37mThe generated password for \e[4m%s\e[24m is:\e[0m\n\e[1m\e[93m%s\e[0m\n" \
+           "$path" "$pass"
+  fi
 }
 
 cmd_delete() {

~~~ step: generic-clip-secure
diff --git a/pass b/pass
--- a/pass
+++ b/pass
@@ -8,6 +8,7 @@ which gpg2 &>/dev/null && GPG="gpg2"
 
 PREFIX="${PASSWORD_STORE_DIR:-$HOME/.password-store2}"
 X_SELECTION="${PASSWORD_STORE_X_SELECTION:-clipboard}"
+CLIP_TIME="${PASSWORD_STORE_CLIP_TIME:-45}"
 GENERATED_LENGTH="${PASSWORD_STORE_GENERATED_LENGTH:-25}"
 CHARACTER_SET="${PASSWORD_STORE_CHARACTER_SET:-[:graph:]}"
 
@@ -96,9 +97,19 @@ check_sneaky_paths() {
 }
 
 clip() {
+  local sleep_argv0="password store sleep on display $DISPLAY"
+  pkill -f "^$sleep_argv0" 2>/dev/null && sleep 0.5
+  local before="$(xclip -o -selection "$X_SELECTION" 2>/dev/null | base64)"
   echo -n "$1" | xclip -selection "$X_SELECTION" \
     || die "Error: Could not copy data to the clipboard"
-  echo "Copied $2 to clipboard."
+  (
+    ( exec -a "$sleep_argv0" bash <<<"trap 'kill %1' TERM; sleep '$CLIP_TIME' & wait" )
+    local now="$(xclip -o -selection "$X_SELECTION" | base64)"
+    [[ $now != $(echo -n "$1" | base64) ]] && before="$now"
+    qdbus org.kde.klipper /klipper org.kde.klipper.klipper.clearClipboardHistory &>/dev/null
+    echo "$before" | base64 -d | xclip -selection "$X_SELECTION"
+  ) 2>/dev/null & disown
+  echo "Copied $2 to clipboard. Will clear in $CLIP_TIME seconds."
 }
 
 source "$(dirname "$0")/platform/$(uname | cut -d _ -f 1 | tr '[:upper:]' '[:lower:]').sh" \

~~~ step: cygwin-clip-secure
diff --git a/platform/cygwin.sh b/platform/cygwin.sh
--- a/platform/cygwin.sh
+++ b/platform/cygwin.sh
@@ -1,6 +1,15 @@
 clip() {
+  local sleep_argv0="password store sleep on display $DISPLAY"
+  pkill -f "^$sleep_argv0" 2>/dev/null && sleep 0.5
+  local before="$(base64 < /dev/clipboard)"
   echo -n "$1" > /dev/clipboard
-  echo "Copied $2 to clipboard."
+  (
+    ( exec -a "$sleep_argv0" sleep "$CLIP_TIME" )
+    local now="$(base64 < /dev/clipboard)"
+    [[ $now != $(echo -n "$1" | base64) ]] && before="$now"
+    echo "$before" | base64 -d > /dev/clipboard
+  ) 2>/dev/null & disown
+  echo "Copied $2 to clipboard. Will clear in $CLIP_TIME seconds."
 }
 
 gpg_winpath() {

~~~ step: macos-clip-secure
diff --git a/platform/darwin.sh b/platform/darwin.sh
--- a/platform/darwin.sh
+++ b/platform/darwin.sh
@@ -1,4 +1,13 @@
 clip() {
+  local sleep_argv0="password store sleep for user $(id -u)"
+  pkill -f "^$sleep_argv0" 2>/dev/null && sleep 0.5
+  local before="$(pbpaste | openssl base64)"
   echo -n "$1" | pbcopy
-  echo "Copied $2 to clipboard."
+  (
+    ( exec -a "$sleep_argv0" sleep "$CLIP_TIME" )
+    local now="$(pbpaste | openssl base64)"
+    [[ $now != $(echo -n "$1" | openssl base64) ]] && before="$now"
+    echo "$before" | openssl base64 -d | pbcopy
+  ) 2>/dev/null & disown
+  echo "Copied $2 to clipboard. Will clear in $CLIP_TIME seconds."
 }

~~~ step: generic-getopt
diff --git a/pass b/pass
--- a/pass
+++ b/pass
@@ -112,6 +112,8 @@ clip() {
   echo "Copied $2 to clipboard. Will clear in $CLIP_TIME seconds."
 }
 
+GETOPT="getopt"
+
 source "$(dirname "$0")/platform/$(uname | cut -d _ -f 1 | tr '[:upper:]' '[:lower:]').sh" \
   2>/dev/null
 

~~~ step: macos-getopt
diff --git a/platform/darwin.sh b/platform/darwin.sh
--- a/platform/darwin.sh
+++ b/platform/darwin.sh
@@ -11,3 +11,8 @@ clip() {
   ) 2>/dev/null & disown
   echo "Copied $2 to clipboard. Will clear in $CLIP_TIME seconds."
 }
+
+GETOPT="$(brew --prefix gnu-getopt 2>/dev/null \
+          || { which port &>/dev/null && echo /opt/local; } \
+          || echo /usr/local \
+	 )/bin/getopt"

~~~ step: freebsd-getopt
diff --git a/platform/freebsd.sh b/platform/freebsd.sh
new file mode 100644
--- /dev/null
+++ b/platform/freebsd.sh
@@ -0,0 +1 @@
+GETOPT="/usr/local/bin/getopt"

~~~ step: openbsd-getopt
diff --git a/platform/openbsd.sh b/platform/openbsd.sh
new file mode 100644
--- /dev/null
+++ b/platform/openbsd.sh
@@ -0,0 +1 @@
+GETOPT="gnugetopt"

~~~ step: use-getopt
diff --git a/pass b/pass
--- a/pass
+++ b/pass
@@ -139,13 +139,15 @@ cmd_usage() {
 	Usage:
 	    $PROGRAM init gpg-id...
 	        Initialize new password storage and use gpg-id for encryption.
-		Reencrypt existing passwords using new gpg-id.
-	    $PROGRAM [show] [-c] pass-name
-	        Show existing password.
+	        Reencrypt existing passwords using new gpg-id.
+	    $PROGRAM [show] [--clip,-c] pass-name
+	        Show existing password and optionally put it on the clipboard.
+	        If put on the clipboard, it will be cleared in $CLIP_TIME seconds.
 	    $PROGRAM insert pass-name
 	        Insert new password.
-	    $PROGRAM generate [-c] pass-name [pass-length]
+	    $PROGRAM generate [--clip,-c] pass-name [pass-length]
 	        Generate a new password of pass-length (or $GENERATED_LENGTH if unspecified).
+	        Optionally put it on the clipboard and clear board after $CLIP_TIME seconds.
 	    $PROGRAM rm pass-name
 	        Remove existing password or directory.
 	    $PROGRAM mv old-path new-path
@@ -175,12 +177,16 @@ cmd_init() {
 }
 
 cmd_show() {
-  local clip=0
-  if [[ $1 == "-c" ]]; then
-    clip=1
-    shift
-  fi
-  [[ $# -ne 1 ]] && die "Usage: $PROGRAM $COMMAND pass-name"
+  local opts clip=0
+  opts="$($GETOPT -o c -l clip -n "$PROGRAM" -- "$@")"
+  local err=$?
+  eval set -- "$opts"
+  while true; do case $1 in
+    -c|--clip) clip=1; shift ;;
+    --) shift; break ;;
+  esac done
+
+  [[ $err -ne 0 || $# -ne 1 ]] && die "Usage: $PROGRAM $COMMAND [--clip,-c] pass-name"
 
   local path="$1"
   local passfile="$PREFIX/$path.gpg"
@@ -190,6 +196,7 @@ cmd_show() {
       $GPG -d "${GPG_OPTS[@]}" "$passfile" || exit $?
     else
       local pass="$($GPG -d "${GPG_OPTS[@]}" "$passfile")"
+      [[ -n $pass ]] || die "There is no password to put on the clipboard."
       clip "$pass" "$path"
     fi
   elif [[ -d $PREFIX/$path ]]; then
@@ -227,13 +234,17 @@ cmd_insert() {
 }
 
 cmd_generate() {
-  local clip=0 pass
-  if [[ $1 == "-c" ]]; then
-    clip=1
-    shift
-  fi
+  local opts clip=0 pass
+  opts="$($GETOPT -o c -l clip -n "$PROGRAM" -- "$@")"
+  local err=$?
+  eval set -- "$opts"
+  while true; do case $1 in
+    -c|--clip) clip=1; shift ;;
+    --) shift; break ;;
+  esac done
 
-  [[ $# -ne 2 && $# -ne 1 ]] && die "Usage: $PROGRAM $COMMAND pass-name [pass-length]"
+  [[ $err -ne 0 || ( $# -ne 2 && $# -ne 1 ) ]] \
+    && die "Usage: $PROGRAM $COMMAND pass-name [pass-length]"
   local path="$1"
   local length="${2:-$GENERATED_LENGTH}"
   check_sneaky_paths "$path"

~~~ step: clip-line-number
diff --git a/pass b/pass
--- a/pass
+++ b/pass
@@ -140,7 +140,7 @@ cmd_usage() {
 	    $PROGRAM init gpg-id...
 	        Initialize new password storage and use gpg-id for encryption.
 	        Reencrypt existing passwords using new gpg-id.
-	    $PROGRAM [show] [--clip,-c] pass-name
+	    $PROGRAM [show] [--clip[=line-number],-c[line-number]] pass-name
 	        Show existing password and optionally put it on the clipboard.
 	        If put on the clipboard, it will be cleared in $CLIP_TIME seconds.
 	    $PROGRAM insert pass-name
@@ -177,16 +177,17 @@ cmd_init() {
 }
 
 cmd_show() {
-  local opts clip=0
-  opts="$($GETOPT -o c -l clip -n "$PROGRAM" -- "$@")"
+  local opts selected_line clip=0
+  opts="$($GETOPT -o c:: -l clip:: -n "$PROGRAM" -- "$@")"
   local err=$?
   eval set -- "$opts"
   while true; do case $1 in
-    -c|--clip) clip=1; shift ;;
+    -c|--clip) clip=1; selected_line="${2:-1}"; shift 2 ;;
     --) shift; break ;;
   esac done
 
-  [[ $err -ne 0 || $# -ne 1 ]] && die "Usage: $PROGRAM $COMMAND [--clip,-c] pass-name"
+  [[ $err -ne 0 || $# -ne 1 ]] \
+    && die "Usage: $PROGRAM $COMMAND [--clip[=line-number],-c[line-number]] pass-name"
 
   local path="$1"
   local passfile="$PREFIX/$path.gpg"
@@ -195,8 +196,10 @@ cmd_show() {
     if [[ $clip -eq 0 ]]; then
       $GPG -d "${GPG_OPTS[@]}" "$passfile" || exit $?
     else
-      local pass="$($GPG -d "${GPG_OPTS[@]}" "$passfile")"
-      [[ -n $pass ]] || die "There is no password to put on the clipboard."
+      [[ $selected_line =~ ^[0-9]+$ ]] || die "Clip location '$selected_line' is not a number."
+      local pass="$($GPG -d "${GPG_OPTS[@]}" "$passfile" | tail -n +${selected_line} | head -n 1)"
+      [[ -n $pass ]] \
+	|| die "There is no password to put on the clipboard at line ${selected_line}."
       clip "$pass" "$path"
     fi
   elif [[ -d $PREFIX/$path ]]; then

~~~ step: insert-opts
diff --git a/pass b/pass
--- a/pass
+++ b/pass
@@ -143,8 +143,10 @@ cmd_usage() {
 	    $PROGRAM [show] [--clip[=line-number],-c[line-number]] pass-name
 	        Show existing password and optionally put it on the clipboard.
 	        If put on the clipboard, it will be cleared in $CLIP_TIME seconds.
-	    $PROGRAM insert pass-name
-	        Insert new password.
+	    $PROGRAM insert [--echo,-e | --multiline,-m] [--force,-f] pass-name
+	        Insert new password. Optionally, echo the password back to the console
+	        during entry. Or, optionally, the entry may be multiline. Prompt before
+	        overwriting existing password unless forced.
 	    $PROGRAM generate [--clip,-c] pass-name [pass-length]
 	        Generate a new password of pass-length (or $GENERATED_LENGTH if unspecified).
 	        Optionally put it on the clipboard and clear board after $CLIP_TIME seconds.
@@ -210,30 +212,54 @@ cmd_show() {
 }
 
 cmd_insert() {
-  [[ $# -ne 1 ]] && die "Usage: $PROGRAM $COMMAND pass-name"
+  local opts multiline=0 noecho=1 force=0
+  opts="$($GETOPT -o mef -l multiline,echo,force -n "$PROGRAM" -- "$@")"
+  local err=$?
+  eval set -- "$opts"
+  while true; do case $1 in
+    -m|--multiline) multiline=1; shift ;;
+    -e|--echo) noecho=0; shift ;;
+    -f|--force) force=1; shift ;;
+    --) shift; break ;;
+  esac done
+
+  [[ $err -ne 0 || ( $multiline -eq 1 && $noecho -eq 0 ) || $# -ne 1 ]] \
+    && die "Usage: $PROGRAM $COMMAND [--echo,-e | --multiline,-m] [--force,-f] pass-name"
   local path="${1%/}"
   local passfile="$PREFIX/$path.gpg"
   check_sneaky_paths "$path"
 
-  [[ -e $passfile ]] && yesno "An entry already exists for $path. Overwite it?"
+  [[ $force -eq 0 && -e $passfile ]] && yesno "An entry already exists for $path. Overwite it?"
 
   mkdir -p -v "$PREFIX/$(dirname "$path")"
   set_gpg_recipients
 
-  local password password_again
-  while true; do
-    read -r -p "Enter password for $path: " -s password || exit 1
+  if [[ $multiline -eq 1 ]]; then
+    echo "Enter contents of $path and press Ctrl+D when finished:"
     echo
-    read -r -p "Retype password for $path: " -s password_again || exit 1
-    echo
-    if [[ $password == "$password_again" ]]; then
-      $GPG -e "${GPG_RECIPIENT_ARGS[@]}" -o "$passfile" "${GPG_OPTS[@]}" <<< "$password" \
-	|| die "Password encryption aborted."
-      break
-    else
-      die "Error: the entered passwords do not match."
-    fi
-  done
+    $GPG -e "${GPG_RECIPIENT_ARGS[@]}" -o "$passfile" "${GPG_OPTS[@]}" \
+      || die "Password encryption aborted."
+  elif [[ $noecho -eq 1 ]]; then
+    local password password_again
+    while true; do
+      read -r -p "Enter password for $path: " -s password || exit 1
+      echo
+      read -r -p "Retype password for $path: " -s password_again || exit 1
+      echo
+      if [[ $password == "$password_again" ]]; then
+	$GPG -e "${GPG_RECIPIENT_ARGS[@]}" -o "$passfile" "${GPG_OPTS[@]}" <<< "$password" \
+	  || die "Password encryption aborted."
+	break
+      else
+	die "Error: the entered passwords do not match."
+      fi
+    done
+  else
+    local password
+    read -r -p "Enter password for $path: " -e password
+    $GPG -e "${GPG_RECIPIENT_ARGS[@]}" -o "$passfile" "${GPG_OPTS[@]}" <<<"$password" \
+      || die "Password encryption aborted."
+  fi
 }
 
 cmd_generate() {

~~~ step: generate-opts
diff --git a/pass b/pass
--- a/pass
+++ b/pass
@@ -11,6 +11,7 @@ X_SELECTION="${PASSWORD_STORE_X_SELECTION:-clipboard}"
 CLIP_TIME="${PASSWORD_STORE_CLIP_TIME:-45}"
 GENERATED_LENGTH="${PASSWORD_STORE_GENERATED_LENGTH:-25}"
 CHARACTER_SET="${PASSWORD_STORE_CHARACTER_SET:-[:graph:]}"
+CHARACTER_SET_NO_SYMBOLS="${PASSWORD_STORE_CHARACTER_SET_NO_SYMBOLS:-[:alnum:]}"
 
 yesno() {
   [[ -t 0 ]] || return 0
@@ -147,9 +148,11 @@ cmd_usage() {
 	        Insert new password. Optionally, echo the password back to the console
 	        during entry. Or, optionally, the entry may be multiline. Prompt before
 	        overwriting existing password unless forced.
-	    $PROGRAM generate [--clip,-c] pass-name [pass-length]
-	        Generate a new password of pass-length (or $GENERATED_LENGTH if unspecified).
+	    $PROGRAM generate [--no-symbols,-n] [--clip,-c] [--in-place,-i | --force,-f] pass-name [pass-length]
+	        Generate a new password of pass-length (or $GENERATED_LENGTH if unspecified) with optionally no symbols.
 	        Optionally put it on the clipboard and clear board after $CLIP_TIME seconds.
+	        Prompt before overwriting existing password unless forced.
+	        Optionally replace only the first line of an existing file with a new password.
 	    $PROGRAM rm pass-name
 	        Remove existing password or directory.
 	    $PROGRAM mv old-path new-path
@@ -263,17 +266,20 @@ cmd_insert() {
 }
 
 cmd_generate() {
-  local opts clip=0 pass
-  opts="$($GETOPT -o c -l clip -n "$PROGRAM" -- "$@")"
+  local opts clip=0 force=0 characters="$CHARACTER_SET" inplace=0 pass
+  opts="$($GETOPT -o ncif -l no-symbols,clip,in-place,force -n "$PROGRAM" -- "$@")"
   local err=$?
   eval set -- "$opts"
   while true; do case $1 in
+    -n|--no-symbols) characters="$CHARACTER_SET_NO_SYMBOLS"; shift ;;
     -c|--clip) clip=1; shift ;;
+    -f|--force) force=1; shift ;;
+    -i|--in-place) inplace=1; shift ;;
     --) shift; break ;;
   esac done
 
-  [[ $err -ne 0 || ( $# -ne 2 && $# -ne 1 ) ]] \
-    && die "Usage: $PROGRAM $COMMAND pass-name [pass-length]"
+  [[ $err -ne 0 || ( $# -ne 2 && $# -ne 1 ) || ( $force -eq 1 && $inplace -eq 1 ) ]] \
+    && die "Usage: $PROGRAM $COMMAND [--no-symbols,-n] [--clip,-c] [--in-place,-i | --force,-f] pass-name [pass-length]"
   local path="$1"
   local length="${2:-$GENERATED_LENGTH}"
   check_sneaky_paths "$path"
@@ -282,12 +288,26 @@ cmd_generate() {
   set_gpg_recipients
   local passfile="$PREFIX/$path.gpg"
 
-  [[ -e $passfile ]] && yesno "An entry already exists for $path. Overwrite it?"
+  [[ $inplace -eq 0 && $force -eq 0 && -e $passfile ]] \
+    && yesno "An entry already exists for $path. Overwrite it?"
 
-  read -r -n $length pass < <(LC_ALL=C tr -dc "$CHARACTER_SET" < /dev/urandom)
+  read -r -n $length pass < <(LC_ALL=C tr -dc "$characters" < /dev/urandom)
   [[ ${#pass} -eq $length ]] || die "Could not generate password from /dev/urandom."
-  $GPG -e "${GPG_RECIPIENT_ARGS[@]}" -o "$passfile" "${GPG_OPTS[@]}" <<<"$pass" \
-    || die "Password encryption aborted."
+  if [[ $inplace -eq 0 ]]; then
+    $GPG -e "${GPG_RECIPIENT_ARGS[@]}" -o "$passfile" "${GPG_OPTS[@]}" <<<"$pass" \
+      || die "Password encryption aborted."
+  else
+    local passfile_temp="${passfile}.tmp.${RANDOM}.${RANDOM}.${RANDOM}.${RANDOM}.--"
+    if $GPG -d "${GPG_OPTS[@]}" "$passfile" \
+         | sed $'1c \\\n'"$(sed 's/[\/&]/\\&/g' <<<"$pass")"$'\n' \
+	 | $GPG -e "${GPG_RECIPIENT_ARGS[@]}" -o "$passfile_temp" "${GPG_OPTS[@]}"
+    then
+      mv "$passfile_temp" "$passfile"
+    else
+      rm -f "$passfile_temp"
+      die "Could not reencrypt new password."
+    fi
+  fi
 
   if [[ $clip -eq 1 ]]; then
     clip "$pass" "$path"

~~~ step: rm-opts
diff --git a/pass b/pass
--- a/pass
+++ b/pass
@@ -153,8 +153,8 @@ cmd_usage() {
 	        Optionally put it on the clipboard and clear board after $CLIP_TIME seconds.
 	        Prompt before overwriting existing password unless forced.
 	        Optionally replace only the first line of an existing file with a new password.
-	    $PROGRAM rm pass-name
-	        Remove existing password or directory.
+	    $PROGRAM rm [--recursive,-r] [--force,-f] pass-name
+	        Remove existing password or directory, optionally forcefully.
 	    $PROGRAM mv old-path new-path
 	        Renames or moves old-path to new-path.
 	    $PROGRAM cp old-path new-path
@@ -318,7 +318,16 @@ cmd_generate() {
 }
 
 cmd_delete() {
-  [[ $# -ne 1 ]] && die "Usage: $PROGRAM $COMMAND pass-name"
+  local opts recursive="" force=0
+  opts="$($GETOPT -o rf -l recursive,force -n "$PROGRAM" -- "$@")"
+  local err=$?
+  eval set -- "$opts"
+  while true; do case $1 in
+    -r|--recursive) recursive="-r"; shift ;;
+    -f|--force) force=1; shift ;;
+    --) shift; break ;;
+  esac done
+  [[ $# -ne 1 ]] && die "Usage: $PROGRAM $COMMAND [--recursive,-r] [--force,-f] pass-name"
   local path="$1"
   check_sneaky_paths "$path"
 
@@ -327,9 +336,9 @@ cmd_delete() {
   [[ -f $passfile && -d $passdir && $path == */ || ! -f $passfile ]] && passfile="${passdir%/}/"
   [[ -e $passfile ]] || die "Error: $path is not in the password store."
 
-  yesno "Are you sure you would like to delete $path?"
+  [[ $force -eq 1 ]] || yesno "Are you sure you would like to delete $path?"
 
-  rm -r -f -v "$passfile"
+  rm $recursive -f -v "$passfile"
   rmdir -p "${passfile%/*}" 2>/dev/null
 }
 

~~~ step: copy-move-opts
diff --git a/pass b/pass
--- a/pass
+++ b/pass
@@ -155,10 +155,10 @@ cmd_usage() {
 	        Optionally replace only the first line of an existing file with a new password.
 	    $PROGRAM rm [--recursive,-r] [--force,-f] pass-name
 	        Remove existing password or directory, optionally forcefully.
-	    $PROGRAM mv old-path new-path
-	        Renames or moves old-path to new-path.
-	    $PROGRAM cp old-path new-path
-	        Copies old-path to new-path.
+	    $PROGRAM mv [--force,-f] old-path new-path
+	        Renames or moves old-path to new-path, optionally forcefully.
+	    $PROGRAM cp [--force,-f] old-path new-path
+	        Copies old-path to new-path, optionally forcefully.
 	    $PROGRAM help
 	        Show this text.
 	    $PROGRAM version
@@ -343,10 +343,17 @@ cmd_delete() {
 }
 
 cmd_copy_move() {
-  local move=1
+  local opts move=1 force=0
   [[ $1 == "copy" ]] && move=0
   shift
-  [[ $# -ne 2 ]] && die "Usage: $PROGRAM $COMMAND old-path new-path"
+  opts="$($GETOPT -o f -l force -n "$PROGRAM" -- "$@")"
+  local err=$?
+  eval set -- "$opts"
+  while true; do case $1 in
+    -f|--force) force=1; shift ;;
+    --) shift; break ;;
+  esac done
+  [[ $# -ne 2 ]] && die "Usage: $PROGRAM $COMMAND [--force,-f] old-path new-path"
   check_sneaky_paths "$@"
   local old_path="$PREFIX/${1%/}"
   local old_dir="$old_path"
@@ -363,7 +370,7 @@ cmd_copy_move() {
   [[ -d $old_path || -d $new_path || $new_path == */ ]] || new_path="${new_path}.gpg"
 
   local interactive="-i"
-  [[ ! -t 0 ]] && interactive="-f"
+  [[ ! -t 0 || $force -eq 1 ]] && interactive="-f"
 
   if [[ $move -eq 1 ]]; then
     mv $interactive -v "$old_path" "$new_path" || exit 1

~~~ step: generic-qrcode
diff --git a/pass b/pass
--- a/pass
+++ b/pass
@@ -113,6 +113,22 @@ clip() {
   echo "Copied $2 to clipboard. Will clear in $CLIP_TIME seconds."
 }
 
+qrcode() {
+  if [[ -n $DISPLAY || -n $WAYLAND_DISPLAY ]]; then
+    if type feh >/dev/null 2>&1; then
+      echo -n "$1" | qrencode --size 10 -o - | feh -x --title "pass: $2" -g +200+200 -
+      return
+    elif type gm >/dev/null 2>&1; then
+      echo -n "$1" | qrencode --size 10 -o - | gm display -title "pass: $2" -geometry +200+200 -
+      return
+    elif type display >/dev/null 2>&1; then
+      echo -n "$1" | qrencode --size 10 -o - | display -title "pass: $2" -geometry +200+200 -
+      return
+    fi
+  fi
+  echo -n "$1" | qrencode -t utf8
+}
+
 GETOPT="getopt"
 
 source "$(dirname "$0")/platform/$(uname | cut -d _ -f 1 | tr '[:upper:]' '[:lower:]').sh" \

~~~ step: macos-qrcode
diff --git a/platform/darwin.sh b/platform/darwin.sh
--- a/platform/darwin.sh
+++ b/platform/darwin.sh
@@ -12,6 +12,18 @@ clip() {
   echo "Copied $2 to clipboard. Will clear in $CLIP_TIME seconds."
 }
 
+qrcode() {
+  if type imgcat >/dev/null 2>&1; then
+    echo -n "$1" | qrencode --size 10 -o - | imgcat
+  elif type gm >/dev/null 2>&1; then
+    echo -n "$1" | qrencode --size 10 -o - | gm display -title "pass: $2" -geometry +200+200 -
+  elif type display >/dev/null 2>&1; then
+    echo -n "$1" | qrencode --size 10 -o - | display -title "pass: $2" -geometry +200+200 -
+  else
+    echo -n "$1" | qrencode -t utf8
+  fi
+}
+
 GETOPT="$(brew --prefix gnu-getopt 2>/dev/null \
           || { which port &>/dev/null && echo /opt/local; } \
           || echo /usr/local \

~~~ step: show-qrcode
diff --git a/pass b/pass
--- a/pass
+++ b/pass
@@ -198,30 +198,35 @@ cmd_init() {
 }
 
 cmd_show() {
-  local opts selected_line clip=0
-  opts="$($GETOPT -o c:: -l clip:: -n "$PROGRAM" -- "$@")"
+  local opts selected_line clip=0 qrcode=0
+  opts="$($GETOPT -o q::c:: -l qrcode::,clip:: -n "$PROGRAM" -- "$@")"
   local err=$?
   eval set -- "$opts"
   while true; do case $1 in
+    -q|--qrcode) qrcode=1; selected_line="${2:-1}"; shift 2 ;;
     -c|--clip) clip=1; selected_line="${2:-1}"; shift 2 ;;
     --) shift; break ;;
   esac done
 
-  [[ $err -ne 0 || $# -ne 1 ]] \
-    && die "Usage: $PROGRAM $COMMAND [--clip[=line-number],-c[line-number]] pass-name"
+  [[ $err -ne 0 || ( $qrcode -eq 1 && $clip -eq 1 ) || $# -ne 1 ]] \
+    && die "Usage: $PROGRAM $COMMAND [--clip[=line-number],-c[line-number]] [--qrcode[=line-number],-q[line-number]] pass-name"
 
   local path="$1"
   local passfile="$PREFIX/$path.gpg"
   check_sneaky_paths "$path"
   if [[ -f $passfile ]]; then
-    if [[ $clip -eq 0 ]]; then
+    if [[ $clip -eq 0 && $qrcode -eq 0 ]]; then
       $GPG -d "${GPG_OPTS[@]}" "$passfile" || exit $?
     else
       [[ $selected_line =~ ^[0-9]+$ ]] || die "Clip location '$selected_line' is not a number."
       local pass="$($GPG -d "${GPG_OPTS[@]}" "$passfile" | tail -n +${selected_line} | head -n 1)"
       [[ -n $pass ]] \
 	|| die "There is no password to put on the clipboard at line ${selected_line}."
-      clip "$pass" "$path"
+      if [[ $clip -eq 1 ]]; then
+	clip "$pass" "$path"
+      elif [[ $qrcode -eq 1 ]]; then
+	qrcode "$pass" "$path"
+      fi
     fi
   elif [[ -d $PREFIX/$path ]]; then
     die "Error: $path is a directory."

~~~ step: generate-qrcode
diff --git a/pass b/pass
--- a/pass
+++ b/pass
@@ -287,20 +287,21 @@ cmd_insert() {
 }
 
 cmd_generate() {
-  local opts clip=0 force=0 characters="$CHARACTER_SET" inplace=0 pass
-  opts="$($GETOPT -o ncif -l no-symbols,clip,in-place,force -n "$PROGRAM" -- "$@")"
+  local opts qrcode=0 clip=0 force=0 characters="$CHARACTER_SET" inplace=0 pass
+  opts="$($GETOPT -o nqcif -l no-symbols,qrcode,clip,in-place,force -n "$PROGRAM" -- "$@")"
   local err=$?
   eval set -- "$opts"
   while true; do case $1 in
     -n|--no-symbols) characters="$CHARACTER_SET_NO_SYMBOLS"; shift ;;
+    -q|--qrcode) qrcode=1; shift ;;
     -c|--clip) clip=1; shift ;;
     -f|--force) force=1; shift ;;
     -i|--in-place) inplace=1; shift ;;
     --) shift; break ;;
   esac done
 
-  [[ $err -ne 0 || ( $# -ne 2 && $# -ne 1 ) || ( $force -eq 1 && $inplace -eq 1 ) ]] \
-    && die "Usage: $PROGRAM $COMMAND [--no-symbols,-n] [--clip,-c] [--in-place,-i | --force,-f] pass-name [pass-length]"
+  [[ $err -ne 0 || ( $# -ne 2 && $# -ne 1 ) || ( $force -eq 1 && $inplace -eq 1 ) || ( $qrcode -eq 1 && $clip -eq 1 ) ]] \
+    && die "Usage: $PROGRAM $COMMAND [--no-symbols,-n] [--clip,-c] [--qrcode,-q] [--in-place,-i | --force,-f] pass-name [pass-length]"
   local path="$1"
   local length="${2:-$GENERATED_LENGTH}"
   check_sneaky_paths "$path"
@@ -332,6 +333,8 @@ cmd_generate() {
 
   if [[ $clip -eq 1 ]]; then
     clip "$pass" "$path"
+  elif [[ $qrcode -eq 1 ]]; then
+    qrcode "$pass" "$path"
   else
     printf "\e[1m\e[37mThe generated password for \e[4m%s\e[24m is:\e[0m\n\e[1m\e[93m%s\e[0m\n" \
            "$path" "$pass"

~~~ step: edit
diff --git a/pass b/pass
--- a/pass
+++ b/pass
@@ -164,6 +164,8 @@ cmd_usage() {
 	        Insert new password. Optionally, echo the password back to the console
 	        during entry. Or, optionally, the entry may be multiline. Prompt before
 	        overwriting existing password unless forced.
+	    $PROGRAM edit pass-name
+	        Insert a new password or edit an existing password using ${EDITOR:-vi}.
 	    $PROGRAM generate [--no-symbols,-n] [--clip,-c] [--in-place,-i | --force,-f] pass-name [pass-length]
 	        Generate a new password of pass-length (or $GENERATED_LENGTH if unspecified) with optionally no symbols.
 	        Optionally put it on the clipboard and clear board after $CLIP_TIME seconds.
@@ -286,6 +288,30 @@ cmd_insert() {
   fi
 }
 
+cmd_edit() {
+  [[ $# -ne 1 ]] && die "Usage: $PROGRAM $COMMAND pass-name"
+
+  local path="${1%/}"
+  check_sneaky_paths "$path"
+  mkdir -p -v "$PREFIX/$(dirname "$path")"
+  set_gpg_recipients
+  local passfile="$PREFIX/$path.gpg"
+
+  local tmp_file="$(mktemp -u "XXXXXX")-${path//\//-}.txt"
+
+  if [[ -f $passfile ]]; then
+    $GPG -d -o "$tmp_file" "${GPG_OPTS[@]}" "$passfile" || exit 1
+  fi
+  ${EDITOR:-vi} "$tmp_file"
+  [[ -f $tmp_file ]] || die "New password not saved."
+  $GPG -d -o - "${GPG_OPTS[@]}" "$passfile" 2>/dev/null \
+    | diff - "$tmp_file" &>/dev/null \
+    && die "Password unchanged."
+  while ! $GPG -e "${GPG_RECIPIENT_ARGS[@]}" -o "$passfile" "${GPG_OPTS[@]}" "$tmp_file"; do
+    yesno "GPG encryption failed. Would you like to try again?"
+  done
+}
+
 cmd_generate() {
   local opts qrcode=0 clip=0 force=0 characters="$CHARACTER_SET" inplace=0 pass
   opts="$($GETOPT -o nqcif -l no-symbols,qrcode,clip,in-place,force -n "$PROGRAM" -- "$@")"
@@ -413,6 +439,7 @@ case "$1" in
   version|--version) shift;  cmd_version "$@" ;;
   show) shift;               cmd_show "$@" ;;
   insert|add) shift;         cmd_insert "$@" ;;
+  edit) shift;               cmd_edit "$@" ;;
   generate) shift;           cmd_generate "$@" ;;
   delete|rm|remove) shift;   cmd_delete "$@" ;;
   rename|mv) shift;          cmd_copy_move "move" "$@" ;;

~~~ step: generic-tmpdir
diff --git a/pass b/pass
--- a/pass
+++ b/pass
@@ -129,7 +129,37 @@ qrcode() {
   echo -n "$1" | qrencode -t utf8
 }
 
+tmpdir() {
+  [[ -n $SECURE_TMPDIR ]] && return
+  local warn=1
+  [[ $1 == "nowarn" ]] && warn=0
+  local template="$PROGRAM.XXXXXXXXXXXXX"
+  if [[ -d /dev/shm && -w /dev/shm && -x /dev/shm ]]; then
+    SECURE_TMPDIR="$(mktemp -d "/dev/shm/$template")"
+    remove_tmpfile() {
+      rm -rf "$SECURE_TMPDIR"
+    }
+    trap remove_tmpfile INT TERM EXIT
+  else
+    [[ $warn -eq 1 ]] && yesno "$(cat <<-_EOF
+	Your system does not have /dev/shm, which means that it may
+	be difficult to entirely erase the temporary non-encrypted
+	password file after editing.
+
+	Are you sure you would like to continue?
+	_EOF
+    )"
+    SECURE_TMPDIR="$(mktemp -d "${TMPDIR:-/tmp}/$template")"
+    shred_tmpfile() {
+      find "$SECURE_TMPDIR" -type f -exec $SHRED {} +
+      rm -rf "$SECURE_TMPDIR"
+    }
+    trap shred_tmpfile INT TERM EXIT
+  fi
+}
+
 GETOPT="getopt"
+SHRED="shred -f -z"
 
 source "$(dirname "$0")/platform/$(uname | cut -d _ -f 1 | tr '[:upper:]' '[:lower:]').sh" \
   2>/dev/null

~~~ step: macos-tmpdir
diff --git a/platform/darwin.sh b/platform/darwin.sh
--- a/platform/darwin.sh
+++ b/platform/darwin.sh
@@ -12,6 +12,24 @@ clip() {
   echo "Copied $2 to clipboard. Will clear in $CLIP_TIME seconds."
 }
 
+tmpdir() {
+  [[ -n $SECURE_TMPDIR ]] && return
+  unmount_tmpdir() {
+    [[ -n $SECURE_TMPDIR && -d $SECURE_TMPDIR && -n $DARWIN_RAMDISK_DEV ]] || return
+    umount "$SECURE_TMPDIR"
+    diskutil quiet eject "$DARWIN_RAMDISK_DEV"
+    rm -rf "$SECURE_TMPDIR"
+  }
+  trap unmount_tmpdir INT TERM EXIT
+  SECURE_TMPDIR="$(mktemp -d "${TMPDIR:-/tmp}/$PROGRAM.XXXXXXXXXXXXX")"
+  DARWIN_RAMDISK_DEV="$(hdid -drivekey system-image=yes -nomount 'ram://32768' | cut -d ' ' -f 1)"
+  [[ -z $DARWIN_RAMDISK_DEV ]] && die "Error: could not create ramdisk."
+  newfs_hfs -M 700 "$DARWIN_RAMDISK_DEV" &>/dev/null \
+    || die "Error could not create filesystem on ramdisk."
+  mount -t hfs -o noatime -o nobrowse "$DARWIN_RAMDISK_DEV" "$SECURE_TMPDIR" \
+    || die "Error: could not mount filesystem on ramdisk."
+}
+
 qrcode() {
   if type imgcat >/dev/null 2>&1; then
     echo -n "$1" | qrencode --size 10 -o - | imgcat
@@ -28,3 +46,4 @@ GETOPT="$(brew --prefix gnu-getopt 2>/dev/null \
           || { which port &>/dev/null && echo /opt/local; } \
           || echo /usr/local \
 	 )/bin/getopt"
+SHRED="srm -f -z"

~~~ step: freebsd-shred
diff --git a/platform/freebsd.sh b/platform/freebsd.sh
--- a/platform/freebsd.sh
+++ b/platform/freebsd.sh
@@ -1 +1,2 @@
 GETOPT="/usr/local/bin/getopt"
+SHRED="rm -P -f"

~~~ step: openbsd-tmpdir
diff --git a/platform/openbsd.sh b/platform/openbsd.sh
--- a/platform/openbsd.sh
+++ b/platform/openbsd.sh
@@ -1 +1,36 @@
+tmpdir() {
+  [[ -n $SECURE_TMPDIR ]] && return
+  local warn=1
+  [[ $1 == "nowarn" ]] && warn=0
+  local template="$PROGRAM.XXXXXXXXXXXXX"
+  if [[ $(sysctl -n kern.usermount) == 1 ]]; then
+    SECURE_TMPDIR="$(mktemp -d "${TMPDIR:-/tmp}/$template")"
+    mount -t tmpfs -o -s16M tmpfs "$SECURE_TMPDIR" || die "Error: could not create tmpfs."
+    unmount_tmpdir() {
+      [[ -n $SECURE_TMPDIR && -d $SECURE_TMPDIR ]] || return
+      umount "$SECURE_TMPDIR"
+      rm -rf "$SECURE_TMPDIR"
+    }
+    trap unmount_tmpdir INT TERM EXIT
+  else
+    [[ $warn -eq 1 ]] && yesno "$(cat <<-_EOF
+	The sysctl kern.usermount is disabled, therefore it is not
+        possible to create a tmpfs for temporary storage of files
+        in memory.
+        This means that it may be difficult to entirely erase
+        the temporary non-encrypted password file after editing.
+
+        Are you sure you would like to continue?
+        _EOF
+    )"
+    SECURE_TMPDIR="$(mktemp -d "${TMPDIR:-/tmp}/$template")"
+    shred_tmpfile() {
+      find "$SECURE_TMPDIR" -type f -exec $SHRED {} +
+      rm -rf "$SECURE_TMPDIR"
+    }
+    trap shred_tmpfile INT TERM EXIT
+  fi
+}
+
 GETOPT="gnugetopt"
+SHRED="rm -P -f"

~~~ step: use-tmpdir
diff --git a/pass b/pass
--- a/pass
+++ b/pass
@@ -327,7 +327,8 @@ cmd_edit() {
   set_gpg_recipients
   local passfile="$PREFIX/$path.gpg"
 
-  local tmp_file="$(mktemp -u "XXXXXX")-${path//\//-}.txt"
+  tmpdir
+  local tmp_file="$(mktemp -u "$SECURE_TMPDIR/XXXXXX")-${path//\//-}.txt"
 
   if [[ -f $passfile ]]; then
     $GPG -d -o "$tmp_file" "${GPG_OPTS[@]}" "$passfile" || exit 1

~~~ step: ls
diff --git a/pass b/pass
--- a/pass
+++ b/pass
@@ -187,6 +187,8 @@ cmd_usage() {
 	    $PROGRAM init gpg-id...
 	        Initialize new password storage and use gpg-id for encryption.
 	        Reencrypt existing passwords using new gpg-id.
+	    $PROGRAM [ls] [subfolder]
+	        List passwords.
 	    $PROGRAM [show] [--clip[=line-number],-c[line-number]] pass-name
 	        Show existing password and optionally put it on the clipboard.
 	        If put on the clipboard, it will be cleared in $CLIP_TIME seconds.
@@ -240,8 +242,8 @@ cmd_show() {
     --) shift; break ;;
   esac done
 
-  [[ $err -ne 0 || ( $qrcode -eq 1 && $clip -eq 1 ) || $# -ne 1 ]] \
-    && die "Usage: $PROGRAM $COMMAND [--clip[=line-number],-c[line-number]] [--qrcode[=line-number],-q[line-number]] pass-name"
+  [[ $err -ne 0 || ( $qrcode -eq 1 && $clip -eq 1 )]] \
+    && die "Usage: $PROGRAM $COMMAND [--clip[=line-number],-c[line-number]] [--qrcode[=line-number],-q[line-number]] [pass-name]"
 
   local path="$1"
   local passfile="$PREFIX/$path.gpg"
@@ -261,7 +263,16 @@ cmd_show() {
       fi
     fi
   elif [[ -d $PREFIX/$path ]]; then
-    die "Error: $path is a directory."
+    if [[ -z $path ]]; then
+      echo "Password Store"
+    else
+      echo "${path%\/}"
+    fi
+    tree -C -l --noreport "$PREFIX/$path" \
+      | tail -n +2 \
+      | sed -E 's/\.gpg(\x1B\[[0-9]+m)?( ->|$)/\1\2/g'
+  elif [[ -z $path ]]; then
+    die "Error: password store is empty. Try \"pass init\"."
   else
     die "Error: $path is not in the password store."
   fi
@@ -468,7 +479,7 @@ case "$1" in
   init) shift;               cmd_init "$@" ;;
   help|--help) shift;        cmd_usage "$@" ;;
   version|--version) shift;  cmd_version "$@" ;;
-  show) shift;               cmd_show "$@" ;;
+  show|ls|list) shift;       cmd_show "$@" ;;
   insert|add) shift;         cmd_insert "$@" ;;
   edit) shift;               cmd_edit "$@" ;;
   generate) shift;           cmd_generate "$@" ;;

~~~ step: find
diff --git a/pass b/pass
--- a/pass
+++ b/pass
@@ -189,6 +189,8 @@ cmd_usage() {
 	        Reencrypt existing passwords using new gpg-id.
 	    $PROGRAM [ls] [subfolder]
 	        List passwords.
+	    $PROGRAM find pass-names...
+	        List passwords that match pass-names.
 	    $PROGRAM [show] [--clip[=line-number],-c[line-number]] pass-name
 	        Show existing password and optionally put it on the clipboard.
 	        If put on the clipboard, it will be cleared in $CLIP_TIME seconds.
@@ -278,6 +280,15 @@ cmd_show() {
   fi
 }
 
+cmd_find() {
+  [[ $# -eq 0 ]] && die "Usage: $PROGRAM $COMMAND pass-names..."
+  IFS="," eval 'echo "Search Terms: $*"'
+  local terms="*$(printf '%s*|*' "$@")"
+  tree -C -l --noreport -P "${terms%|*}" --prune --matchdirs --ignore-case "$PREFIX" \
+    | tail -n +2 \
+    | sed -E 's/\.gpg(\x1B\[[0-9]+m)?( ->|$)/\1\2/g'
+}
+
 cmd_insert() {
   local opts multiline=0 noecho=1 force=0
   opts="$($GETOPT -o mef -l multiline,echo,force -n "$PROGRAM" -- "$@")"
@@ -480,6 +491,7 @@ case "$1" in
   help|--help) shift;        cmd_usage "$@" ;;
   version|--version) shift;  cmd_version "$@" ;;
   show|ls|list) shift;       cmd_show "$@" ;;
+  find|search) shift;        cmd_find "$@" ;;
   insert|add) shift;         cmd_insert "$@" ;;
   edit) shift;               cmd_edit "$@" ;;
   generate) shift;           cmd_generate "$@" ;;

~~~ step: grep
diff --git a/pass b/pass
--- a/pass
+++ b/pass
@@ -194,6 +194,8 @@ cmd_usage() {
 	    $PROGRAM [show] [--clip[=line-number],-c[line-number]] pass-name
 	        Show existing password and optionally put it on the clipboard.
 	        If put on the clipboard, it will be cleared in $CLIP_TIME seconds.
+	    $PROGRAM grep search-string
+	        Search for password files containing search-string when decrypted.
 	    $PROGRAM insert [--echo,-e | --multiline,-m] [--force,-f] pass-name
 	        Insert new password. Optionally, echo the password back to the console
 	        during entry. Or, optionally, the entry may be multiline. Prompt before
@@ -289,6 +291,22 @@ cmd_find() {
     | sed -E 's/\.gpg(\x1B\[[0-9]+m)?( ->|$)/\1\2/g'
 }
 
+cmd_grep() {
+  [[ $# -ne 1 ]] && die "Usage: $PROGRAM $COMMAND search-string"
+  local search="$1" passfile grepresults
+  while read -r -d "" passfile; do
+    grepresults="$($GPG -d "${GPG_OPTS[@]}" "$passfile" | grep --color=always "$search")"
+    [[ $? -ne 0 ]] && continue
+    passfile="${passfile%.gpg}"
+    passfile="${passfile#$PREFIX/}"
+    local passfile_dir="${passfile%/*}/"
+    [[ $passfile_dir == "${passfile}/" ]] && passfile_dir=""
+    passfile="${passfile##*/}"
+    printf "\e[94m%s\e[1m%s\e[0m:\n" "$passfile_dir" "$passfile"
+    echo "$grepresults"
+  done < <(find -L "$PREFIX" -path '*/.git' -prune -o -iname '*.gpg' -print0)
+}
+
 cmd_insert() {
   local opts multiline=0 noecho=1 force=0
   opts="$($GETOPT -o mef -l multiline,echo,force -n "$PROGRAM" -- "$@")"
@@ -492,6 +510,7 @@ case "$1" in
   version|--version) shift;  cmd_version "$@" ;;
   show|ls|list) shift;       cmd_show "$@" ;;
   find|search) shift;        cmd_find "$@" ;;
+  grep) shift;               cmd_grep "$@" ;;
   insert|add) shift;         cmd_insert "$@" ;;
   edit) shift;               cmd_edit "$@" ;;
   generate) shift;           cmd_generate "$@" ;;
